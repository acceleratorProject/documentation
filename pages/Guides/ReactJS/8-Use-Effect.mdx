**Introducci√≥n**
---

Este Hook nos permite "escuchar" o "engancharnos‚Äù a los eventos en el tiempo y poder ejecutar c√≥digo de forma din√°mica, vamos a comenzar por algo sencillo como ejecutar un c√≥digo cuando el componente se monta en el DOM. 

**Gesti√≥n de la asincronia**
---

Vamos  crear un componente llamado `EffectOnLoad.jsx`.

```tsx
import { useState } from "react";

export const EffectOnLoad = () => {
  const [myName, setMyName] = useState("David");

  return (
    <>
      <h4>{myName}</h4>
      <input
        type="text"
        value={myName}
        onChange={(e) => setMyName(e.target.value)}
      />
    </>
  );
};
```

Hay muchas operaciones que realizamos justo cuando se carga el DOM del navegador como por ejemplo cargar el perfil de un usuario con la informaci√≥n provista de una API. Tambi√©n pueden ser operaciones que queremos ejecutar cuando cambie un valor o despu√©s de cada render que realiza React bajo nuestra demanda. 

Pero ¬øqu√© sucede si esas operaciones que queremos realizar no son s√≠ncronas? Pues que tendremos que usar el hook useEffect porque si lo realizamos en un componente funcional no obtendremos el resultado deseado, ya que estos se crean y se destruyen, y con este hook podremos gestionar los ‚Äúside effects‚Äù de nuestras aplicaciones.

Vamos a ver c√≥mo funciona con dos ejemplos sencillos, el primero ser√° cambiar un nombre cuando se pinta el componente, y luego haremos otro simulando una llamada as√≠ncrona con un `setTimeout`. Vamos con la l√≥gica de nuestro componente üöÄ.

En primer lugar queremos a√±adir un valor por defecto a nuestro state pero solamente cuando el componente se haya renderizado en el DOM y no de inicio, para ello usaremos useEffect.

```tsx
useEffect(() => {
	setMyName("Ziggy Stardust");
}, []);
```

Os recuerdo que el `[]` vac√≠o hace referencia a que no hay ninguna condici√≥n para re-ejecutar este efecto, por lo que solo ocurrir√° una vez en la vida de nuestro componente.

De este modo nuestro componente queda `EffectOnLoad.jsx` queda.

```tsx
import { useState, useEffect } from "react";

export const EffectOnLoad: React.FC = () => {
  const [myName, setMyName] = useState("David");

  useEffect(() => {
    setMyName("Ziggy Stardust");
  }, []);

  return (
    <>
      <h4>{myName}</h4>
      <input
        type="text"
        value={myName}
        onChange={(e) => setMyName(e.target.value)}
      />
    </>
  );
};
```

**Vamos a ver como funciona un poco el useEffect**, es hook que tiene **dos par√°metros:**

- El primero es obligatorio siendo un c√≥digo que se ejecuta cuando es llamado (suele ser una llamada a un servidor, un timeout...) en forma de callback, que no debe ser una funci√≥n async/await, pero si que pueden serlo las funciones declaradas en su interior.
- El segundo vamos a verlo con ejemplos a continuaci√≥n, ya que consiste en un array de dependencias que queremos escuchar...

El hook useEffect se ejecuta **siempre** en el primer render de nuestro componente, y a partir de aqu√≠ tendremos control sobre cuando relanzarlo. Para los que vengan de componentes de clase de React, se podr√≠a decir que esto se parece al m√©todo componentDidMount que se usaba antes de los componentes funcionales, aunque no son exactamente lo mismo.

```tsx
useEffect(() => {
  setMyName("Ziggy Stardust");
}, []);
```

Cuando a√±adimos un valor al array de dependencias, la funci√≥n del useEffect se ejecutar√° tambi√©n cada vez que cambia dicho valor, en este caso `myName`, y en el caso de nuestro componente del ejemplo anterior, cada vez que cambie el state.

```tsx
useEffect(() => {
  setMyName("Ziggy Stardust");
}, [myName]);
```

Este ejemplo representa c√≥digo un poco inadecuado porque dentro del useEffect estamos modificando el state que ya hemos cambiado previamente, pero m√°s adelante veremos ejemplos en los que tiene sentido hacer algo parecido.

Si no pasamos el segundo par√°metro a useEffect, se ejecutar√° tambi√©n despu√©s de cada render y tendremos una ejecuci√≥n continua en cualquier interacci√≥n de nuestra aplicaci√≥n.

```tsx
useEffect(() => {
  setMyName("Ziggy Stardust");
});
```

Para cerrar este ejemplo vamos a simular una llamada as√≠ncrona con un setTimeout y veremos c√≥mo trabaja el useEffect.

```tsx
useEffect(() => {
  // Imagina que esto fuese la respuesta de una API
  setTimeout(() => {
    setMyName("Ziggy Stardust");
  }, 1500);
}, []);
```

Al recargar tarda 1,5s en ejecutar nuestro c√≥digo del useEffect ... ‚è∞