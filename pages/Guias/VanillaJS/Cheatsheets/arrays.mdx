**Introducción**
---

La manera de representar un listado de elementos en programación, se denomina Array. Un array está compuesto por varios ítems, entre corchetes **[ ]**.

```jsx
let listYears = [1972, 1984, 1988, 1992, 1997, 2021, 2022];
let listNames = ["Captain America", "Spiderman", "IronMan"];
let listSuperHeroes = [
  { id: 1, name: 'Tony Stark' },
  { id: 4, name: 'Peter Parker' },
];
```

**Declarar y acceder a los elementos de un Array**
---

Pensemos en el array como una lista de elementos, cada uno con su posición **(empezando por la 0)**. Para acceder a la primera posición del array, basta con poner entre corchetes el número 0.

```jsx
let avengers = ["Hulk", "SpiderMan", "AntMan"];

let avenger = avengers[0]; // Probad a cambiar este numero ;)
console.log(avenger) // Devuelve "Hulk"
```

**Métodos que modifican el array**
---

Vamos a ver varios métodos que nos da el lenguaje y como vamos a trabajar con ellos. Primero veremos los métodos que modifican nuestro array inicial.

Vamos a declarar un array de una manera diferente, no es lo tradicional pero así vemos el funcionamiento de las posiciones.

```jsx
let moderatIII = new Array();
            moderatIII[0] = "Eating hooks";
            moderatIII[1] = "Running";
            moderatIII[2] = "Finder";
            moderatIII[3] = "Ghostmother";
            moderatIII[4] = "Reminder";
            moderatIII[5] = "Intruder";
            moderatIII[6] = "Animal trails";    

console.log(moderatIII);
```

**pop()** no admite parámetros. Elimina el último elemento del array.

```jsx
moderatIII.pop();

console.log(moderatIII);
```

**push()** entre los paréntesis se pueden añadir tantos valores como se quiera añadir a  el array, separados por comas (**,**). Añade un elemento al array en última posición.

```jsx
moderatIII.push('Ethereal');

console.log(moderatIII);
```

**reverse()** tampoco admite parámetros. Invierte el orden del array.

```jsx
moderatIII.reverse();

console.log(moderatIII);
```

**shift()** funciona como **pop()**, pero extrayendo del array el primer elemento. Todos los índices de la matriz se actualizan.

```jsx
moderatIII.shift();
```

**sort()** ordena los elementos del array, tal y como ordena los nombres de archivo un ordenador, es decir:

- Los valores como los de esta matriz se ordenan por orden alfabético.

- Si la matriz consiste en una serie de números, estos se ordenan según las cifras más a la izquierda, de menor a mayor. Así, por ejemplo, una matriz que consista en **200,35,40,1** no se ordenará según el valor de las cifras —**1,35,40,200**—, sino que **sort()** devolverá **1,200,35,40**.

```jsx
moderatIII.sort();

console.log(moderatIII);
```

**splice()** es un método especial, cuyo comportamiento depende de los parámetros que se le asignen:

- El **primer parámetro** es un **número** que representa el **índice** desde el que tiene que **empezar a modificar la matriz**.

- El **segundo** es otro **número** que indica el número de **elementos** que debe **eliminar** o **sustituir**, contando el inicial (por ello un valor de **0** no modifica nada en absoluto).

- Tras estos dos parámetros, se puede incluir una **lista de elementos** separados por comas:
    
    
    - Si **no** se incluye ningún **elemento**, **splice()** simplemente **elimina** tantos elementos como se han indicado en el segundo parámetro, tomando como índice inicial el primer parámetro.
    
    - Si se **incluyen** **menos elementos** que el valor del **segundo parámetro**, **rellena los «huecos»** disponibles hasta quedarse sin valores, **y elimina los que faltan**.
    
    - Si **se incluyen más elementos** que el valor del **segundo parámetr**o, primero **elimina los indicados**, y luego **inserta todos los elementos** proporcionados entre el anterior y el posterior a la sección eliminada. Sin embargo, en este caso **splice()** **no devuelve la parte del array seccionada** como en los anteriores, **sino la nueva longitud**.
    

```jsx
moderatIII.splice(2,2);

console.log(moderatIII);

moderatIII.splice(2,2,'Ethereal');

console.log(moderatIII);

moderatIII.splice(2,2,'Ethereal','Ethereal Remix vol.1','Ethereal Remix vol.2');

console.log(moderatIII);
```

Como parámetros se puede proporcionar a **unshift()** una serie de elementos separados por comas, que se **añaden al principio de la matriz**. Los índices se actualizan en consecuencia, y el método devuelve la nueva longitud.

```jsx
moderatIII.unshift('Reminder Remix vol.1','Reminder Remix vol.2')
```

**Métodos que no modifican la matriz**
---

Estos métodos devuelven una representación del array, pero no lo modifican. Vamos a emplear los dos arrays siguientes.

```jsx

    let moderatII = new Array();
        moderatII[0] = "The Mark";
        moderatII[1] = "Bad Kingdom";
        moderatII[2] = "Versions";
        moderatII[3] = "Milk";
        moderatII[4] = "Gita";
        moderatII[5] = "Damage Done";
        
    let moderat = new Array();
        moderat[0] = "Rusty nails";
        moderat[1] = "Seanmonkey";
        moderat[2] = "Nasty silence";
        moderat[3] = "Berlin";
            
```

**concat()** en este caso he **concatenado la segunda matriz a la primera**, pero se pueden encadenar una serie de elementos separados por comas, o incluso varias matrices.

```jsx
moderatII.concat(moderat);

console.log(moderatII.concat(moderat));

console.log(moderatII);

console.log(moderat);
```

Como se puede ver, sin embargo, la matriz **moderat** no ha sido alterada.

Empleado sin un parámetro, **join()** devuelve una mera cadena en la que los valores del array están separados por comas. Sin embargo, se puede especificar una cadena que sirva como separador.

```jsx
moderatII.join('-');

console.log(moderatII);
```

**slice()** extrae una copia de una sección especificada de una matriz, aunque a diferencia de **splice()** no la modifica.

Para este método el primer parámetro es obligatorio y el segundo opcional:

- Definidos ambos naturales, el primero es el índice desde el que debe comenzarse la copia (se incluye ese elemento en la misma), y el segundo el índice en el que debe detenerse (y este elemento que no se incluye).

- Definido sólo uno, cuenta como el índice desde el que comenzar la copia, que abarcará los elementos hasta el final de la matriz.

```jsx
moderatII.slice(2,4);

console.log(moderatII);

moderatIII.slice(3);

console.log(moderatIII);
```

**toString()** este método es similar a **join()**, sólo que no admite parámetros, y que el resultado es un objeto String, con sus propias propiedades y métodos.

```jsx
moderatII.toString()

console.log(moderatII);
```

**Localizar un valor en un array**
---

Por último, recojo dos métodos muy útiles para localizar valores en un array.

```jsx

let modeSelector = ["Who", "Fentanyl", "Tom", "Dy"]
            
```

**indexOf()** devuelve el índice del primer elemento que coincide con el parámetro proporcionado.

```jsx
modeSelector.indexOf('Who');
```

Si no se da coincidencia, devuelve -1.

```jsx
modeSelector.indexOf('Pastis');
```

**lastIndexOf()** devuelve el índice del último elemento que coincide con el parámetro proporcionado.

```jsx
modeSelector.lastIndexOf('Who');
```

Si no se da coincidencia, también devuelve -1:

```jsx
modeSelector.lastIndexOf('Pastis');
```

En realidad estos dos métodos son un poco limitados, pero son útiles precisamente cuando se está comprobando la **no existencia** de un elemento en un Array.

**includes()** determina si una matriz incluye un determinado elemento, devuelve true o false según corresponda.

```jsx
const listNumbers = [1, 2, 3];

console.log(listNumbers.includes(2));
// expected output: true

const listFilms = ['Reservoir dogs', 'The Big Lewoski', 'End Game'];

console.log(listFilms.includes('dogs'));
// expected output: true

console.log(listFilms.includes('og'));
// expected output: false
```

**Spread Operator**
---

El operador de propagación spread operator permite que una expresión **sea expandida** en situaciones donde se esperan múltiples argumentos (llamadas a funciones) o múltiples elementos (arrays literales).

```jsx
let xmen = ['Ciclops', 'Beast', 'Angel', 'Marvel-girl'];
let newXmen = ['Wolverine', 'NightCrawler', 'Storm'];

// Antes se usaba el concat y ahora ...
let myMutants = [...xmen, ...newXmen];

// Se puede usar también para copiar un array
let xmenCopy = [...xmen];

// se usa para jugar con tu array sin modificarlo
let [lastMutant] = [...xmen].reverse();

// No se ha modificado
console.log(xmen);
console.log(lastMutant)
```

**array.map()**
---

Os explicaremos cómo funciona con un ejemplo simple. Supongamos que ha recibido un ***array*** que **contiene varios objetos**, cada uno de los cuales representa a una persona. 

```jsx
// Lo que tenemos 

var officers = [  
  { id: 20, name: 'Captain Piett' },  
  { id: 24, name: 'General Veers' },  
  { id: 56, name: 'Admiral Ozzel' },  
  { id: 88, name: 'Commander Jerjerrod' }
];

// Lo que necesitamos [20, 24, 56, 88]
```

> Hay múltiples formas de lograr esto. Es posible hacerlo creando un array vacío y luego usando .forEach(), .for(... of) o un simple .for() para cumplir su objetivo.
> 

Usando ***.forEach()***:

```jsx
var officersIds = [];

officers.forEach((officer) => {  
  officersIds.push(officer.id);
});
```

Usando ***.map()***:

```jsx
const officersIds = officers.map(officer => [officer.id](http://officer.id/));
```

Entonces, ¿cómo funciona .***map()***? Básicamente  **recibe dos argumentos**, una devolución de llamada y un contexto opcional (se considerará así en la devolución de llamada) que no utilicé en el ejemplo anterior. La devolución de llamada se ejecuta para cada valor en el ***array*** y devuelve cada nuevo valor en el ***array*** resultante.

```jsx
var arr = [{
  id: 1,
  name: 'bill'
}, {
  id: 2,
  name: 'ted'
}]

var result = arr.map(person => ({ value: person.id, text: person.name }));

console.log(result)
```

Tenemos que tener en cuenta que el ***array*** que nos devuelve siempre tendrá la misma longitud que el original. Pero es un ***array*** nuevo, el original no se ha modificado.

**array.filter()**
---

¿Qué sucede si tiene una matriz, pero solo quiere algunos de sus elementos? ¡Ahí es donde entra en juego .filter()! Aquí están nuestros datos:

```jsx
var pilots = [ 
{ id: 2, name: "Wedge Antilles", faction: "Rebels", }, 
{ id: 8, name: "Ciena Ree", faction: "Empire", }, 
{ id: 40, name: "Iden Versio", faction: "Empire", }, 
{ id: 66, name: "Thane Kyrell", faction: "Rebels", }];
```

Digamos que queremos dos conjuntos ahora: uno para los pilotos rebeldes, el otro para los imperiales. ¡Con .filter() no podría ser más fácil!

```jsx
var rebels = pilots.filter(function (pilot) {  
return pilot.faction === "Rebels";});

var empire = pilots.filter(function (pilot) {  
return pilot.faction === "Empire";});
```

¡Eso es! Y es aún más corto con las arrow functions:

```jsx
const rebels = pilots.filter(pilot => pilot.faction === "Rebels");

const empire = pilots.filter(pilot => pilot.faction === "Empire");
```

**array.find()**
---

El método find() devuelve el valor del primer elemento del array que cumple la función de prueba proporcionada.

```jsx
const array1 = [5, 12, 8, 130, 44];

const found = array1.find(element => element > 10);

console.log(found);
// expected output: 12
```

**array.reduce()**
---

Al igual que ***.map()***, ***.reduce()*** también ejecuta una devolución de llamada para cada elemento de un ***array***. Lo diferente aquí es que **reduce el resultado** de esta devolución de llamada (el acumulador) de un elemento del ***array*** a otro.

> El acumulador puede ser prácticamente cualquier cosa (entero, cadena, objeto, etc.) y debe instanciarse o pasarse al llamar a .reduce().
> 

¡Hora de un ejemplo! Digamos que tienes una ***Array*** con estos pilotos y sus respectivos años de experiencia.

```jsx
var pilots = [ 
	{ id: 10, name: "Poe Dameron", years: 14, }, 
	{ id: 2, name: "Temmin 'Snap' Wexley", years: 30, }, 
	{ id: 41, name: "Tallissan Lintra", years: 16, }, 
	{ id: 99, name: "Ello Asty", years: 22, }
];
```

Necesitamos conocer el **total de años de experiencia** de todos ellos. Con **.reduce()**, es bastante sencillo.

```jsx
var totalYears = pilots.reduce(function (accumulator, pilot) { 
return accumulator + pilot.years;}, 0);
```

Tenemos en cuenta que hemos establecido el **valor inicial en 0**. También podría haber usado una variable existente si fuera necesario. Después de ejecutar la devolución de llamada para cada elemento del array, reduce devolverá el valor final de nuestro acumulador (en nuestro caso: 82).

Veamos cómo se puede acortar esto con las funciones de flecha de ES6.

```jsx
const totalYears = pilots.reduce((acc, pilot) => acc + pilot.years, 0);
```

Ahora digamos que quiero encontrar qué piloto es el más experimentado. Para eso, puedo usar .reduce() también.

```jsx
var mostExpPilot = pilots.reduce(function (oldest, pilot) { 
return (oldest.years || 0) > pilot.years ? oldest : pilot;}, {});
```

Llamé a mi acumulador más antiguo. Mi callback de llamada compara el acumulador con cada piloto. Si un piloto tiene más años de experiencia que el más antiguo, entonces ese piloto se convierte en el nuevo más viejo, así que ese es el que esta dentro del return.

Como puedes ver, usar .reduce() es una manera fácil de generar un único valor u objeto a partir de una matriz. 

**Ejemplo final: Combinando .map(), .reduce(), and .filter()**
---

Nuestro objetivo: obtener la puntuación total de los usuarios de la fuerza solamente. ¡Hagámoslo paso a paso!

```jsx
var personnel = [ 
	{ id: 5, name: "Luke Skywalker", pilotingScore: 98, shootingScore: 56, isForceUser: true, }, 
	{ id: 82, name: "Sabine Wren", pilotingScore: 73, shootingScore: 99, isForceUser: false, }, 
	{ id: 22, name: "Zeb Orellios", pilotingScore: 20, shootingScore: 59, isForceUser: false, }, 
	{ id: 15, name: "Ezra Bridger", pilotingScore: 43, shootingScore: 67, 
	isForceUser: true, }, 
	{ id: 11, name: "Caleb Dume", pilotingScore: 71, shootingScore: 85, 
	isForceUser: true, }
];
```

Primero, necesitamos filtrar al personal que no puede usar la fuerza.

```jsx
var jediPersonnel = personnel.filter(
  function (person) {  
    return person.isForceUser;
  }
);

// Result: [{...}, {...}, {...}] (Luke, Ezra and Caleb)
```

Con eso nos quedan 3 elementos en nuestra matriz resultante. Ahora necesitamos crear una matriz que contenga la puntuación total de cada Jedi.

```jsx
var jediScores = jediPersonnel.map(
  function (jedi) {  
		return jedi.pilotingScore + jedi.shootingScore;
  }
);// Result: [154, 110, 156]
```

Y usemos .reduce() para obtener el total.

```jsx
var totalJediScore = jediScores.reduce(
  function (acc, score) {  
    return acc + score;
  }, 0
); // Result: 420
```

Y ahora esta es la parte divertida ... podemos encadenar todo esto para obtener lo que queremos en una sola línea.

```jsx
var totalJediScore = personnel
	.filter(function (person) { 
		return person.isForceUser;
	})
	.map(function (jedi) { 
		return jedi.pilotingScore + jedi.shootingScore;
	})
	.reduce(function (acc, score) { 
		return acc + score;
	}, 0);
```

Y ahora haciendo uso de las arrow functions.

```jsx
const totalJediScore = personnel.filter(person => person.isForceUser)
	.map(jedi => jedi.pilotingScore + jedi.shootingScore)
	.reduce((acc, score) => acc + score, 0);
```